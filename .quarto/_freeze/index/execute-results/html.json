{
  "hash": "2d5b639d36b78aefed718085fd36fb50",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Métodos Estadísticos para la mineria de datos\"\ntoc: false\nnumber-sections: true\n---\n\n\n\n\nLa filosofía de la minería de datos trata de la conversión de datos en conocimiento para la toma de decisiones, y como tal constituye la fase central del proceso de extracción de conocimiento a partir de bases de datos. La minería de datos es un punto de encuentro de diferentes disciplinas: \n\n-  la estadística, \n-  el aprendizaje automático (*machine learning*)\n-  las técnicas de bases de datos \n-  los sistemas para la toma de decisiones. \n\nJuntas permiten afrontar muchos problemas actuales en cuanto al tratamiento de la información.\n\nLa asignatura introduce las técnicas más usuales para la resolución de tres tipos de problemas fundamentales: el análisis de datos binarios (*transacciones*), el análisis de datos científicos (por ejemplo, de genómica) y el análisis de datos de empresas; los cuales configuran buena parte de los problemas actuales que trata la minería de datos.\n\nComo objetivo paralelo hay utilizar la R, un potente en torno a programación libre.\n\n## Introducción a la mineria de datos\n\nLa minería de datos es el proceso de extraer patrones, tendencias y conocimientos útiles a partir de grandes volúmenes de datos. Combina estadística, aprendizaje automático y bases de datos para ayudar a resolver problemas en diversas áreas, como negocios, ciencia y tecnología.\n\n[Teoria]()\n\n[Laboratorio - Software Carpentry](material/SoftwareCarpentry/SoftwareCarpentry.qmd)\n\n[Laboratorio - Preprocessing]()\n\n## Clustering \n\nEl clustering agrupa datos similares en clústeres basados en características compartidas. Es útil para descubrir patrones ocultos y segmentar conjuntos de datos, comúnmente aplicado en marketing, biología y análisis de redes.\n\n[Teoria]()\n\n[Laboratorio]()\n\n## Visualización de datos\n\nLa visualización de datos convierte información compleja en gráficos y representaciones visuales claras, facilitando la interpretación y comunicación de resultados. Herramientas como gráficos de dispersión, histogramas y mapas de calor son fundamentales.\n\n### Analisis de componentes principales (ACP)\n\nEl ACP reduce la dimensionalidad de los datos al identificar las combinaciones lineales más relevantes de las variables originales, conservando la mayor parte de la variación. Se usa para simplificar datos y facilitar su interpretación.\n\n[Teoria]()\n\n[Laboratorio]()\n\n### Analisis de correspondiencias múltiples (ACM)\n\nEl ACM analiza tablas de datos categóricos para identificar relaciones entre categorías, visualizando patrones en mapas bidimensionales que facilitan la interpretación.\n\n[Teoria]()\n\n[Laboratorio]()\n\n## Reglas de asociación\n\nEste método identifica relaciones significativas entre variables en grandes bases de datos. Es clave en aplicaciones como los sistemas de recomendación y análisis de cestas de mercado.\n\n[Teoria]()\n\n[Laboratorio]()\n\n## Reglas de clasificación\n\nLos modelos de clasificación asignan datos a categorías predefinidas basándose en patrones aprendidos. Es ampliamente usado en diagnóstico médico, detección de fraudes y análisis de texto.\n\n### Lineal Discriminant Analysis (LDA) y Quadratic Discriminant Analysis (QDA)\n\nAmbos métodos buscan separar categorías utilizando fronteras de decisión basadas en estadísticas. LDA asume varianzas iguales entre clases, mientras que QDA permite varianzas diferentes.\n\n[Teoria]()\n\n[Laboratorio]()\n\n### Naives Bayes\n\nUn clasificador basado en probabilidad que asume independencia entre las características. Es eficiente y se aplica en problemas como clasificación de texto y detección de spam.\n\n[Teoria]()\n\n[Laboratorio]()\n\n## Métodos particionales \n\nDividen datos en subconjuntos o particiones, a menudo mediante árboles de decisión y técnicas relacionadas.\n\n### Decisions Tree\n\nModelo gráfico que toma decisiones en base a condiciones secuenciales. Es intuitivo y útil en clasificación y regresión.\n\n### Random Forest\n\nCombina múltiples árboles de decisión para mejorar precisión y reducir sobreajuste. Es robusto y adecuado para tareas de clasificación y regresión.\n\n### Bagging & Boosting\n\nMétodos de ensamblado que mejoran el rendimiento combinando múltiples modelos. Bagging reduce la variabilidad, mientras que Boosting optimiza errores iterativamente.\n\n[Teoria]()\n\n[Laboratorio](material/trees_ensambleMethods/DecisionsTree_RandomForest_XGBoost.qmd)\n\n## Métodos flexibles de discriminación \n\n### Support Vectors Machines (SVM)\n\nSeparan clases usando hiperplanos óptimos en un espacio de alta dimensionalidad. Son efectivas en problemas no lineales y clasificación compleja.\n\n[Teoria]()\n\n[Laboratorio]()\n\n## Deep Learning \n\nEl aprendizaje profundo utiliza redes neuronales para modelar datos complejos. Es ampliamente aplicado en reconocimiento de imágenes, procesamiento de lenguaje natural y más.\n\n### Redes neuronales: Discriminación pel perceptrón multicapa\n\nLas redes multicapa, basadas en múltiples capas de neuronas interconectadas, resuelven problemas no lineales con alta precisión.\n\n### Redes neuronales convolucionales\n\nEspecializadas en procesar datos con estructura espacial, como imágenes. Extraen automáticamente características relevantes para tareas como clasificación de imágenes y visión por computadora.\n\n[Teoria](material/ANN/ANN.pdf)\n\n[Datos de deportes](material/ANN/img_deportes.zip)\n\n[Detección de imagenes deportivas](material/ANN/Ejercicio_CNN_Deportes.zip)\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n[DreamBooth (parte 1)](material/ANN/01_DreamBooth_parte1.zip)\n\n**Importante:** Para poder hacer uso de este script es necesario que tengas: \n\n- Entre 2 y 3 fotos de cuerpo entero\n\n- Entre 3 y 5 fotos de medio cuerpo\n\n- Entorno a 10 fotos de cara\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n[DreamBooth (parte 2)](material/ANN/02_DreamBooth_parte2.zip)\n\n[DreamBooth (completo)](material/ANN/Script_dreambooth.zip)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}